#!/usr/bin/env python
from misc.utility.scons_hints import *

Import("env")
Import("env_modules")

env_dotnet = env_modules.Clone()


def is_desktop(platform: str) -> bool:
    return platform in ["windows", "macos", "linuxbsd"]


def is_mobile(platform: str) -> bool:
    return platform in ["android", "ios"]


def is_browser(platform: str) -> bool:
    return platform in ["web"]


def is_hostfxr_supported(platform: str) -> bool:
    return is_desktop(platform)


def is_monovm_supported(platform: str) -> bool:
    return is_desktop(platform) or is_mobile(platform)


def is_nativeaot_supported(platform: str) -> bool:
    return is_desktop(platform) or is_mobile(platform)


def get_godot_dotnet_package_version() -> str:
    import version

    version_str = f"{version.major}.{version.minor}.{version.patch}"
    if version.status == "stable":
        # For stable versions, use the latest revision version available.
        version_str += ".*"
    else:
        # Pre-releases and development builds.

        # If version was overridden to be e.g. "beta3", we insert a dot between
        # "beta" and "3" to follow SemVer 2.0.
        import re

        version_status = version.status
        match = re.search(r"[\d]+$", version.status)
        if match:
            pos = match.start()
            version_status = version.status[:pos]

            # "dev" pre-releases always use the "alpha" label in the .NET packages.
            if version_status == "dev":
                version_status = "alpha"

            version_status += f".{version.status[pos:]}"
        else:
            # If the version status is not numbered, it must be a development build.
            # Development builds always use the "dev" label in the .NET packages.
            version_status = "dev"

        version_str += f"-{version_status}"

    return version_str


# Configure .NET

platform = env["platform"]

if is_hostfxr_supported(platform):
    env_dotnet.Append(CPPDEFINES=["DOTNET_HOSTFXR_ENABLED"])
if is_monovm_supported(platform):
    env_dotnet.Append(CPPDEFINES=["DOTNET_MONOVM_ENABLED"])
if is_nativeaot_supported(platform):
    env_dotnet.Append(CPPDEFINES=["DOTNET_NATIVEAOT_ENABLED"])

if env.editor_build:
    if not is_desktop(platform):
        raise RuntimeError(
            f".NET module does not currently support building the editor for this platform: {platform}."
        )

# Add sources.

env_dotnet.add_source_files(env.modules_sources, "*.cpp")
env_dotnet.add_source_files(env.modules_sources, "extension/*.cpp")
env_dotnet.add_source_files(env.modules_sources, "runtime/*.cpp")
env_dotnet.add_source_files(env.modules_sources, "runtime/**/*.cpp")
env_dotnet.add_source_files(env.modules_sources, "utils/*.cpp")

if env.editor_build:
    env_dotnet.add_source_files(env.modules_sources, "editor/*.cpp")


# Add RestoreEditorPackages.proj
def make_proj(target, source, env):
    from pathlib import Path

    src_path = Path(str(source[0]))
    src_name = src_path.stem

    version_str = str(source[1])

    proj = ""
    with open(str(source[0]), "r", newline="\r\n", encoding="utf-8") as file:
        file_str = file.read()
        file_str = file_str.replace(
            "<_GodotPackagesVersion>*-*</_GodotPackagesVersion>",
            f"<_GodotPackagesVersion>{version_str}</_GodotPackagesVersion>",
        )
        proj += "".join(f"\\{hex(x)[1:]}" for x in bytes(file_str, "utf-8"))

    import methods

    with methods.generated_wrapper(str(target[0])) as file:
        file.write(
            f"""\
#include "core/typedefs.h"

#ifdef TOOLS_ENABLED
static const char *_{src_name}_proj = "{proj}";
#endif // TOOLS_ENABLED
"""
        )


version_str = get_godot_dotnet_package_version()

env_dotnet.CommandNoCache(
    "editor/RestoreEditorPackages.proj.gen.h",
    ["editor/RestoreEditorPackages.proj", env_dotnet.Value(version_str)],
    env_dotnet.Run(make_proj),
)
